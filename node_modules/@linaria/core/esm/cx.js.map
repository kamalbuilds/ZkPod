{"version":3,"file":"cx.js","names":["cx","presentClassNames","Array","prototype","slice","call","arguments","filter","Boolean","atomicClasses","nonAtomicClasses","forEach","arg","individualClassNames","split","className","startsWith","keyHash","push","result","Object","hasOwnProperty","join"],"sources":["../src/cx.ts"],"sourcesContent":["export type LinariaClassName = string & { __linariaClassName: true };\n\nexport type ClassName<T = string> = T | false | void | null | 0 | '';\n\ninterface ICX {\n  (...classNames: ClassName<LinariaClassName>[]): LinariaClassName;\n  (...classNames: ClassName[]): string;\n}\n/**\n * Takes a list of class names and filters for truthy ones, joining them into a single class name for convenience.\n * eg.\n * ```js\n *  cx('red', isBig && 'big') // returns 'red big' if `isBig` is true, otherwise returns 'red'\n * ```\n * If space separated atomic styles are provided, they are deduplicated according to the first hashed valued:\n *\n * ```js\n *  cx('atm_a_class1 atm_b_class2', 'atm_a_class3') // returns `atm_a_class3 atm_b_class2`\n * ```\n *\n * @returns the combined, space separated class names that can be applied directly to the class attribute\n */\nconst cx: ICX = function cx() {\n  const presentClassNames: (ClassName | ClassName<LinariaClassName>)[] =\n    Array.prototype.slice\n      // eslint-disable-next-line prefer-rest-params\n      .call(arguments)\n      .filter(Boolean);\n\n  const atomicClasses: { [k: string]: string } = {};\n  const nonAtomicClasses: string[] = [];\n  presentClassNames.forEach((arg) => {\n    // className could be the output of a previous cx call, so split by ' ' first\n    const individualClassNames = arg ? arg.split(' ') : [];\n\n    individualClassNames.forEach((className) => {\n      if (className.startsWith('atm_')) {\n        const [, keyHash] = className.split('_');\n        atomicClasses[keyHash] = className;\n      } else {\n        nonAtomicClasses.push(className);\n      }\n    });\n  });\n\n  const result: string[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const keyHash in atomicClasses) {\n    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {\n      result.push(atomicClasses[keyHash]);\n    }\n  }\n\n  result.push(...nonAtomicClasses);\n\n  return result.join(' ') as LinariaClassName;\n};\n\nexport default cx;\n"],"mappings":"AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,EAAO,GAAG,SAASA,EAAT,GAAc;EAC5B,MAAMC,iBAA8D,GAClEC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CACE;EADF,CAEGC,IAFH,CAEQC,SAFR,EAGGC,MAHH,CAGUC,OAHV,CADF;EAMA,MAAMC,aAAsC,GAAG,EAA/C;EACA,MAAMC,gBAA0B,GAAG,EAAnC;EACAT,iBAAiB,CAACU,OAAlB,CAA2BC,GAAD,IAAS;IACjC;IACA,MAAMC,oBAAoB,GAAGD,GAAG,GAAGA,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAH,GAAoB,EAApD;IAEAD,oBAAoB,CAACF,OAArB,CAA8BI,SAAD,IAAe;MAC1C,IAAIA,SAAS,CAACC,UAAV,CAAqB,MAArB,CAAJ,EAAkC;QAChC,MAAM,GAAGC,OAAH,IAAcF,SAAS,CAACD,KAAV,CAAgB,GAAhB,CAApB;QACAL,aAAa,CAACQ,OAAD,CAAb,GAAyBF,SAAzB;MACD,CAHD,MAGO;QACLL,gBAAgB,CAACQ,IAAjB,CAAsBH,SAAtB;MACD;IACF,CAPD;EAQD,CAZD;EAcA,MAAMI,MAAgB,GAAG,EAAzB,CAvB4B,CAyB5B;;EACA,KAAK,MAAMF,OAAX,IAAsBR,aAAtB,EAAqC;IACnC,IAAIW,MAAM,CAACjB,SAAP,CAAiBkB,cAAjB,CAAgChB,IAAhC,CAAqCI,aAArC,EAAoDQ,OAApD,CAAJ,EAAkE;MAChEE,MAAM,CAACD,IAAP,CAAYT,aAAa,CAACQ,OAAD,CAAzB;IACD;EACF;;EAEDE,MAAM,CAACD,IAAP,CAAY,GAAGR,gBAAf;EAEA,OAAOS,MAAM,CAACG,IAAP,CAAY,GAAZ,CAAP;AACD,CAnCD;;AAqCA,eAAetB,EAAf"}